# Testing Development Guidelines

This rule set guides the AI agent in implementing comprehensive testing strategies for the Lib Vue Components library. The guidelines cover unit testing, component testing, E2E testing, and testing best practices based on Vue 3 + TypeScript + Tailwind CSS architecture.

## Core Testing Principles

- **Testing Pyramid**: Unit tests (foundation) â†’ Component tests (integration) â†’ E2E tests (user journeys)
- **Vue 3 First**: Use Vue Test Utils with Composition API and `<script setup>` syntax
- **TypeScript Safety**: Leverage TypeScript for type-safe testing
- **Accessibility First**: Include accessibility testing in all test suites
- **Performance Aware**: Fast test execution with parallel processing
- **Coverage Driven**: Maintain high test coverage for critical paths

## Testing Stack & Tools

### Primary Testing Framework
- **Vitest**: Vite-native testing framework for unit and component tests
- **Vue Test Utils**: Official Vue testing utilities
- **@testing-library/vue**: User-centric testing approach (optional)

### E2E Testing (Storybook-Based)
- **Storybook**: Primary E2E testing platform for component library
- **@storybook/test**: Interaction testing and user journey validation
- **@storybook/addon-interactions**: Visual testing and debugging
- **@storybook/test-runner**: Automated test execution for all stories

### Visual & Accessibility Testing
- **Storybook**: Component documentation and visual testing
- **@storybook/test**: Interaction testing in Storybook
- **axe-core**: Accessibility testing

## Project Structure

```
tests/
â”œâ”€â”€ unit/                    # Unit tests (Vitest + Vue Test Utils)
â”‚   â”œâ”€â”€ elements/           # Basic component unit tests
â”‚   â”œâ”€â”€ complex/            # Advanced component unit tests
â”‚   â”œâ”€â”€ shell/              # Layout component unit tests
â”‚   â”œâ”€â”€ utils/              # Utility function tests
â”‚   â”œâ”€â”€ stores/             # State management tests
â”‚   â””â”€â”€ composables/        # Composable function tests
â”œâ”€â”€ component/              # Component integration tests
â”‚   â”œâ”€â”€ forms/              # Form workflow tests
â”‚   â”œâ”€â”€ interactions/       # User interaction tests
â”‚   â””â”€â”€ accessibility/      # A11y component tests
â”œâ”€â”€ e2e/                    # End-to-end tests (Storybook-based)
â”‚   â”œâ”€â”€ interactions/       # Component interaction tests
â”‚   â”œâ”€â”€ workflows/          # Multi-component workflow tests
â”‚   â”œâ”€â”€ accessibility/      # A11y E2E tests
â”‚   â””â”€â”€ visual/             # Visual regression tests
â”œâ”€â”€ fixtures/               # Test data and mocks
â”‚   â”œâ”€â”€ data/               # Test data files
â”‚   â”œâ”€â”€ mocks/              # Mock implementations
â”‚   â””â”€â”€ helpers/            # Test utilities
â””â”€â”€ __mocks__/              # Global mocks
```

## Testing Categories & Priorities

### High Priority (Core Functionality)
1. **Form Components**: Input, TextArea, CheckboxInput, FileInputCombo
2. **Interactive Components**: Button, Dropdown, Modal, Tabs
3. **State Management**: Theme switching, RTL toggle, store integration

### Medium Priority (User Experience)
1. **Layout Components**: DashboardShell, SidebarMenu, HorizontalMenu
2. **Utility Components**: Toast, Progress, Tooltip
3. **Accessibility**: ARIA attributes, keyboard navigation

### Low Priority (Visual/Edge Cases)
1. **Icon System**: Icon rendering, variants
2. **Theme Customization**: Color schemes, responsive design
3. **Performance**: Large datasets, memory usage

---

## Unit Testing Guidelines

### Test File Structure
```typescript
// tests/unit/elements/Button.test.ts
import { describe, it, expect, vi } from 'vitest'
import { mount } from '@vue/test-utils'
import Button from '@/elements/Button.vue'

describe('Button Component', () => {
  // Test suite structure
})
```

### Component Testing Patterns

#### Basic Component Test
```typescript
describe('Button Component', () => {
  it('renders with default props', () => {
    const wrapper = mount(Button)
    expect(wrapper.find('button').exists()).toBe(true)
    expect(wrapper.classes()).toContain('btn-primary')
  })

  it('emits click event when clicked', async () => {
    const wrapper = mount(Button)
    await wrapper.find('button').trigger('click')
    expect(wrapper.emitted('click')).toBeTruthy()
  })

  it('applies variant classes correctly', () => {
    const wrapper = mount(Button, {
      props: { variant: 'danger' }
    })
    expect(wrapper.classes()).toContain('btn-danger')
  })
})
```

#### Form Component Testing
```typescript
describe('Input Component', () => {
  it('supports v-model binding', async () => {
    const wrapper = mount(Input, {
      props: { modelValue: 'initial' }
    })
    
    const input = wrapper.find('input')
    await input.setValue('new value')
    
    expect(wrapper.emitted('update:modelValue')).toEqual([['new value']])
  })

  it('handles validation states', () => {
    const wrapper = mount(Input, {
      props: { 
        error: true,
        errorMessage: 'Invalid input'
      }
    })
    
    expect(wrapper.classes()).toContain('error')
    expect(wrapper.text()).toContain('Invalid input')
  })

  it('supports keyboard events', async () => {
    const wrapper = mount(Input)
    const input = wrapper.find('input')
    
    await input.trigger('keyup.enter')
    expect(wrapper.emitted('keyup.enter')).toBeTruthy()
  })
})
```

#### Interactive Component Testing
```typescript
describe('Dropdown Component', () => {
  it('toggles visibility on trigger click', async () => {
    const wrapper = mount(Dropdown)
    const trigger = wrapper.find('[data-test="dropdown-trigger"]')
    
    await trigger.trigger('click')
    expect(wrapper.find('[data-test="dropdown-menu"]').isVisible()).toBe(true)
    
    await trigger.trigger('click')
    expect(wrapper.find('[data-test="dropdown-menu"]').isVisible()).toBe(false)
  })

  it('closes on escape key', async () => {
    const wrapper = mount(Dropdown)
    await wrapper.find('[data-test="dropdown-trigger"]').trigger('click')
    
    await wrapper.trigger('keydown.escape')
    expect(wrapper.find('[data-test="dropdown-menu"]').isVisible()).toBe(false)
  })
})
```

### State Management Testing
```typescript
describe('App Store', () => {
  it('toggles dark mode', () => {
    const store = useAppStore()
    
    expect(store.isDarkMode).toBe(false)
    store.toggleDarkMode()
    expect(store.isDarkMode).toBe(true)
  })

  it('handles RTL mode', () => {
    const store = useAppStore()
    
    expect(store.isRtl).toBe(false)
    store.setRtlMode(true)
    expect(store.isRtl).toBe(true)
  })
})
```

---

## Component Integration Testing

### Form Workflow Testing
```typescript
describe('Form Integration', () => {
  it('validates complete form submission', async () => {
    const wrapper = mount(FormComponent)
    
    // Fill required fields
    await wrapper.find('[data-test="email-input"]').setValue('test@example.com')
    await wrapper.find('[data-test="password-input"]').setValue('password123')
    await wrapper.find('[data-test="submit-button"]').trigger('click')
    
    expect(wrapper.emitted('submit')).toBeTruthy()
  })
})
```

### Theme Integration Testing
```typescript
describe('Theme Integration', () => {
  it('applies theme classes correctly', () => {
    const store = useAppStore()
    store.setDarkMode(true)
    
    const wrapper = mount(Component)
    expect(wrapper.classes()).toContain('dark')
  })
})
```

---

## E2E Testing Guidelines (Storybook-Based)

### Storybook Interaction Testing
```typescript
// src/elements/Button.stories.ts
import type { Meta, StoryObj } from '@storybook/vue3'
import { expect, userEvent, within } from '@storybook/test'
import Button from './Button.vue'

const meta = {
  title: 'Elements/Button',
  component: Button,
  parameters: {
    // Enable interaction testing
    interactions: {
      disable: false,
    },
  },
} satisfies Meta<typeof Button>

export default meta
type Story = StoryObj<typeof meta>

export const InteractiveButton: Story = {
  args: {
    label: 'Click me',
    color: 'primary',
  },
  play: async ({ canvasElement, step }) => {
    const canvas = within(canvasElement)
    
    await step('Click button and verify event emission', async () => {
      const button = canvas.getByRole('button', { name: /click me/i })
      await userEvent.click(button)
      
      // Verify button state or emitted events
      expect(button).toBeInTheDocument()
    })
  },
}
```

### Accessibility E2E Testing
```typescript
// src/elements/Input.stories.ts
export const AccessibleInput: Story = {
  args: {
    label: 'Email Address',
    placeholder: 'Enter your email',
    type: 'email',
    required: true,
  },
  play: async ({ canvasElement, step }) => {
    const canvas = within(canvasElement)
    
    await step('Verify accessibility attributes', async () => {
      const input = canvas.getByRole('textbox', { name: /email address/i })
      const label = canvas.getByText(/email address/i)
      
      expect(input).toHaveAttribute('type', 'email')
      expect(input).toHaveAttribute('required')
      expect(label).toBeInTheDocument()
    })
    
    await step('Test keyboard navigation', async () => {
      const input = canvas.getByRole('textbox', { name: /email address/i })
      
      await userEvent.tab()
      expect(input).toHaveFocus()
      
      await userEvent.type(input, 'test@example.com')
      expect(input).toHaveValue('test@example.com')
    })
  },
}
```

### Visual Regression Testing
```typescript
// src/elements/Button.stories.ts
export const VisualRegression: Story = {
  args: {
    label: 'Primary Button',
    color: 'primary',
    size: 'md',
  },
  parameters: {
    // Visual regression testing configuration
    viewports: [320, 768, 1200],
  },
  play: async ({ canvasElement, step }) => {
    const canvas = within(canvasElement)
    
    await step('Verify visual appearance', async () => {
      const button = canvas.getByRole('button', { name: /primary button/i })
      expect(button).toBeInTheDocument()
      expect(button).toHaveClass('btn-primary')
    })
  },
}
```

---

## Accessibility Testing Guidelines

### Unit Level A11y Testing
```typescript
describe('Accessibility', () => {
  it('has proper ARIA attributes', () => {
    const wrapper = mount(Button, {
      props: { 'aria-label': 'Submit form' }
    })
    
    expect(wrapper.attributes('aria-label')).toBe('Submit form')
  })

  it('supports keyboard navigation', async () => {
    const wrapper = mount(Button)
    
    await wrapper.trigger('keydown.enter')
    expect(wrapper.emitted('click')).toBeTruthy()
    
    await wrapper.trigger('keydown.space')
    expect(wrapper.emitted('click')).toBeTruthy()
  })
})
```

### E2E A11y Testing
```typescript
// src/elements/Form.stories.ts
export const AccessibilityAudit: Story = {
  args: {
    // Form component props
  },
  parameters: {
    // Enable accessibility testing
    a11y: {
      config: {
        rules: [
          { id: 'color-contrast', enabled: true },
          { id: 'label', enabled: true },
          { id: 'button-name', enabled: true },
        ],
      },
    },
  },
  play: async ({ canvasElement, step }) => {
    const canvas = within(canvasElement)
    
    await step('Run accessibility audit', async () => {
      // Storybook automatically runs a11y tests
      // Additional manual checks can be added here
      const form = canvas.getByRole('form')
      expect(form).toBeInTheDocument()
    })
  },
}
```

---

## Testing Utilities & Helpers

### Test Utilities
```typescript
// tests/fixtures/helpers/test-utils.ts
import { mount, VueWrapper } from '@vue/test-utils'
import { createPinia } from 'pinia'
import { vi } from 'vitest'

export function createTestWrapper(component: any, options = {}) {
  const pinia = createPinia()
  
  return mount(component, {
    global: {
      plugins: [pinia],
      stubs: {
        'router-link': true,
        'router-view': true
      }
    },
    ...options
  })
}

export function mockResizeObserver() {
  global.ResizeObserver = vi.fn().mockImplementation(() => ({
    observe: vi.fn(),
    unobserve: vi.fn(),
    disconnect: vi.fn()
  }))
}
```

### Test Data Fixtures
```typescript
// tests/fixtures/data/user-data.ts
export const mockUser = {
  id: 1,
  name: 'Test User',
  email: 'test@example.com',
  avatar: '/avatar.jpg'
}

export const mockFormData = {
  email: 'test@example.com',
  password: 'password123',
  remember: true
}
```

---

## CI/CD Integration

### GitHub Actions Workflow
```yaml
# .github/workflows/test.yml
name: Test Suite

on: [push, pull_request]

jobs:
  unit-tests:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - uses: actions/setup-node@v3
      - run: yarn install
      - run: yarn test:unit
      - run: yarn test:coverage

  e2e-tests:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - uses: actions/setup-node@v3
      - run: yarn install
      - run: yarn build-storybook
      - run: yarn test:e2e
```

### Package.json Scripts
```json
{
  "scripts": {
    "test": "vitest",
    "test:unit": "vitest unit",
    "test:component": "vitest component",
    "test:e2e": "storybook test",
    "test:storybook": "test-storybook",
    "test:visual": "storybook test",
    "test:coverage": "vitest --coverage",
    "test:ci": "vitest run && test-storybook",
    "test:watch": "vitest --watch",
    "test:ui": "vitest --ui",
    "test:interactions": "test-storybook --watch"
  }
}
```

---

## Testing Best Practices

### 1. Test Organization
- **Co-locate tests**: Keep test files close to source files
- **Descriptive names**: Use clear, descriptive test names
- **Group related tests**: Use `describe` blocks for logical grouping
- **Follow AAA pattern**: Arrange, Act, Assert

### 2. Test Data Management
- **Use factories**: Create test data factories for consistent data
- **Avoid hardcoded values**: Use constants for test data
- **Clean up**: Reset state between tests
- **Mock external dependencies**: Mock APIs, timers, and browser APIs

### 3. Component Testing
- **Test user behavior**: Focus on user interactions, not implementation
- **Test accessibility**: Include accessibility tests in every component
- **Test edge cases**: Handle error states, loading states, empty states
- **Test responsive behavior**: Test mobile and desktop layouts

### 4. Performance Testing
- **Fast execution**: Keep unit tests under 100ms each
- **Parallel execution**: Use parallel test execution
- **Mock heavy operations**: Mock file uploads, API calls, animations
- **Monitor test performance**: Track test execution times

### 5. Coverage Strategy
- **Aim for 90%+ coverage**: Focus on critical business logic
- **Don't chase 100%**: Some code is not worth testing
- **Cover user paths**: Prioritize user-facing functionality
- **Monitor coverage trends**: Track coverage over time

---

## Common Testing Patterns

### Form Testing Pattern
```typescript
describe('Form Component', () => {
  it('validates required fields', async () => {
    const wrapper = mount(FormComponent)
    
    // Submit without filling required fields
    await wrapper.find('form').trigger('submit')
    
    // Check for validation errors
    expect(wrapper.text()).toContain('This field is required')
  })

  it('submits valid data', async () => {
    const wrapper = mount(FormComponent)
    
    // Fill form with valid data
    await wrapper.find('[name="email"]').setValue('test@example.com')
    await wrapper.find('[name="password"]').setValue('password123')
    
    // Submit form
    await wrapper.find('form').trigger('submit')
    
    // Verify submission
    expect(wrapper.emitted('submit')).toBeTruthy()
  })
})
```

### Modal Testing Pattern
```typescript
describe('Modal Component', () => {
  it('opens and closes correctly', async () => {
    const wrapper = mount(Modal)
    
    // Initially closed
    expect(wrapper.find('.modal').isVisible()).toBe(false)
    
    // Open modal
    await wrapper.setProps({ isOpen: true })
    expect(wrapper.find('.modal').isVisible()).toBe(true)
    
    // Close modal
    await wrapper.find('.close-button').trigger('click')
    expect(wrapper.emitted('close')).toBeTruthy()
  })

  it('traps focus when open', async () => {
    const wrapper = mount(Modal, {
      props: { isOpen: true }
    })
    
    // Focus should be trapped inside modal
    await wrapper.find('.modal').trigger('keydown.tab')
    expect(wrapper.find('.modal').contains(wrapper.find(':focus'))).toBe(true)
  })
})
```

### Theme Testing Pattern
```typescript
describe('Theme Integration', () => {
  it('applies theme classes', () => {
    const store = useAppStore()
    store.setDarkMode(true)
    
    const wrapper = mount(Component)
    expect(wrapper.classes()).toContain('dark')
  })

  it('responds to theme changes', async () => {
    const wrapper = mount(Component)
    const store = useAppStore()
    
    // Initial light theme
    expect(wrapper.classes()).not.toContain('dark')
    
    // Switch to dark theme
    store.setDarkMode(true)
    await wrapper.vm.$nextTick()
    
    expect(wrapper.classes()).toContain('dark')
  })
})
```

---

## Storybook-Based E2E Testing Patterns

### Multi-Component Workflow Testing
```typescript
// src/elements/FormWorkflow.stories.ts
export const CompleteFormWorkflow: Story = {
  render: () => ({
    components: { Input, Button, CheckboxInput },
    template: `
      <form @submit.prevent="handleSubmit">
        <Input v-model="form.email" label="Email" type="email" required />
        <Input v-model="form.password" label="Password" type="password" required />
        <CheckboxInput v-model="form.remember" label="Remember me" />
        <Button type="submit" label="Submit" />
      </form>
    `,
    setup() {
      const form = ref({
        email: '',
        password: '',
        remember: false
      })
      
      const handleSubmit = () => {
        // Handle form submission
      }
      
      return { form, handleSubmit }
    }
  }),
  play: async ({ canvasElement, step }) => {
    const canvas = within(canvasElement)
    
    await step('Fill out form fields', async () => {
      const emailInput = canvas.getByRole('textbox', { name: /email/i })
      const passwordInput = canvas.getByRole('textbox', { name: /password/i })
      const checkbox = canvas.getByRole('checkbox', { name: /remember me/i })
      
      await userEvent.type(emailInput, 'test@example.com')
      await userEvent.type(passwordInput, 'password123')
      await userEvent.click(checkbox)
      
      expect(emailInput).toHaveValue('test@example.com')
      expect(passwordInput).toHaveValue('password123')
      expect(checkbox).toBeChecked()
    })
    
    await step('Submit form', async () => {
      const submitButton = canvas.getByRole('button', { name: /submit/i })
      await userEvent.click(submitButton)
      
      // Verify form submission behavior
    })
  },
}
```

### Theme and RTL Testing
```typescript
// src/elements/ThemeTesting.stories.ts
export const ThemeVariations: Story = {
  args: {
    label: 'Theme Test Button',
    color: 'primary',
  },
  parameters: {
    viewports: [320, 768, 1200],
  },
  play: async ({ canvasElement, step }) => {
    const canvas = within(canvasElement)
    
    await step('Verify theme-specific styling', async () => {
      const button = canvas.getByRole('button')
      expect(button).toBeInTheDocument()
      
      // Theme-specific class checks
      const isDarkMode = document.body.classList.contains('dark')
      if (isDarkMode) {
        expect(button).toHaveClass('dark:bg-gray-800')
      } else {
        expect(button).toHaveClass('bg-white')
      }
    })
  },
}
```

### Responsive Design Testing
```typescript
// src/shell/DashboardShell.stories.ts
export const ResponsiveLayout: Story = {
  parameters: {
    viewports: [
      { name: 'mobile', width: 320, height: 568 },
      { name: 'tablet', width: 768, height: 1024 },
      { name: 'desktop', width: 1200, height: 800 },
    ],
  },
  play: async ({ canvasElement, step }) => {
    const canvas = within(canvasElement)
    
    await step('Verify responsive behavior', async () => {
      const sidebar = canvas.getByTestId('sidebar')
      const mainContent = canvas.getByTestId('main-content')
      
      // Check viewport-specific behavior
      const viewport = window.innerWidth
      if (viewport < 768) {
        expect(sidebar).toHaveClass('hidden')
      } else {
        expect(sidebar).toBeVisible()
      }
    })
  },
}
```

### Component State Testing
```typescript
// src/elements/Modal.stories.ts
export const ModalStateManagement: Story = {
  args: {
    isOpen: false,
    title: 'Test Modal',
  },
  play: async ({ canvasElement, step }) => {
    const canvas = within(canvasElement)
    
    await step('Modal starts closed', async () => {
      const modal = canvas.queryByRole('dialog')
      expect(modal).not.toBeInTheDocument()
    })
    
    await step('Open modal', async () => {
      // Trigger modal open (via props or trigger)
      const trigger = canvas.getByRole('button', { name: /open modal/i })
      await userEvent.click(trigger)
      
      const modal = canvas.getByRole('dialog')
      expect(modal).toBeInTheDocument()
      expect(modal).toHaveAttribute('aria-modal', 'true')
    })
    
    await step('Close modal', async () => {
      const closeButton = canvas.getByRole('button', { name: /close/i })
      await closeButton.click()
      
      const modal = canvas.queryByRole('dialog')
      expect(modal).not.toBeInTheDocument()
    })
  },
}
```

### Performance Testing
```typescript
// src/elements/DataTable.stories.ts
export const PerformanceTest: Story = {
  args: {
    data: generateLargeDataset(1000), // 1000 rows
  },
  play: async ({ canvasElement, step }) => {
    const canvas = within(canvasElement)
    
    await step('Measure render performance', async () => {
      const startTime = performance.now()
      
      const table = canvas.getByRole('table')
      expect(table).toBeInTheDocument()
      
      const endTime = performance.now()
      const renderTime = endTime - startTime
      
      // Assert reasonable render time (adjust threshold as needed)
      expect(renderTime).toBeLessThan(100) // 100ms threshold
    })
    
    await step('Test scrolling performance', async () => {
      const tableBody = canvas.getByTestId('table-body')
      
      // Simulate scrolling
      await userEvent.scroll(tableBody, { target: { scrollTop: 500 } })
      
      // Verify smooth scrolling behavior
      expect(tableBody.scrollTop).toBe(500)
    })
  },
}
```

---

## Storybook Testing Configuration

### .storybook/main.ts Configuration
```typescript
import type { StorybookConfig } from "@storybook/vue3-vite"

const config: StorybookConfig = {
  stories: ["../src/**/*.stories.@(js|jsx|ts|tsx)"],
  addons: [
    "@storybook/addon-essentials",
    "@storybook/addon-interactions", // Required for interaction testing
    "@storybook/addon-a11y", // Accessibility testing
  ],
  framework: {
    name: "@storybook/vue3-vite",
    options: {},
  },
  // Enable interaction testing
  features: {
    interactionsDebugger: true,
  },
}

export default config
```

### .storybook/preview.ts Configuration
```typescript
import type { Preview } from "@storybook/vue3"

const preview: Preview = {
  parameters: {
    // Global interaction testing settings
    interactions: {
      disable: false,
      enableV6: true,
    },
    // Global accessibility settings
    a11y: {
      config: {
        rules: [
          { id: 'color-contrast', enabled: true },
          { id: 'label', enabled: true },
        ],
      },
    },

  },
}

export default preview
```

---

## Storybook Component Testing Setup & Configuration

### Installation & Setup

#### Required Dependencies
```bash
yarn add --dev @storybook/test @storybook/addon-interactions
```

#### Storybook Configuration
```typescript
// .storybook/main.ts
import type { StorybookConfig } from '@storybook/vue3-vite'

const config: StorybookConfig = {
  framework: '@storybook/vue3-vite',
  stories: ['../src/**/*.mdx', '../src/**/*.stories.@(js|jsx|mjs|ts|tsx)'],
  addons: [
    // Other Storybook addons
    '@storybook/addon-interactions', // ðŸ‘ˆ Register the addon
  ],
  // Enable interaction testing
  features: {
    interactionsDebugger: true,
  },
}

export default config
```

#### Preview Configuration
```typescript
// .storybook/preview.ts
import type { Preview } from '@storybook/vue3'

const preview: Preview = {
  parameters: {
    // Global interaction testing settings
    interactions: {
      disable: false,
      enableV6: true,
    },
    // Global accessibility settings
    a11y: {
      config: {
        rules: [
          { id: 'color-contrast', enabled: true },
          { id: 'label', enabled: true },
          { id: 'button-name', enabled: true },
        ],
      },
    },
  },
  // Global setup for all stories
  async beforeEach() {
    // Reset mocks and state before each story
    MockDate.reset()
  },
  // Global cleanup for all stories
  async beforeAll() {
    // Initialize global dependencies
    await init()
  },
}

export default preview
```

### Component Testing with Play Functions

#### Basic Play Function Pattern
```typescript
// src/elements/Button.stories.ts
import type { Meta, StoryObj } from '@storybook/vue3'
import { userEvent, within, expect } from '@storybook/test'
import Button from './Button.vue'

const meta: Meta<typeof Button> = {
  component: Button,
  parameters: {
    interactions: {
      disable: false,
    },
  },
}

export default meta
type Story = StoryObj<typeof meta>

export const InteractiveButton: Story = {
  args: {
    label: 'Click me',
    color: 'primary',
  },
  play: async ({ canvasElement, step }) => {
    const canvas = within(canvasElement)
    
    await step('Click button and verify event emission', async () => {
      const button = canvas.getByRole('button', { name: /click me/i })
      await userEvent.click(button)
      
      // Verify button state or emitted events
      expect(button).toBeInTheDocument()
    })
  },
}
```

#### Form Component Testing with Play Functions
```typescript
// src/elements/LoginForm.stories.ts
import type { Meta, StoryObj } from '@storybook/vue3'
import { userEvent, within, expect, fn } from '@storybook/test'
import LoginForm from './LoginForm.vue'

const meta: Meta<typeof LoginForm> = {
  component: LoginForm,
  args: {
    onSubmit: fn(), // Mock function for testing
  },
}

export default meta
type Story = StoryObj<typeof meta>

export const FilledForm: Story = {
  play: async ({ canvasElement, args, step }) => {
    const canvas = within(canvasElement)
    
    await step('Enter credentials', async () => {
      await userEvent.type(canvas.getByTestId('email'), 'email@provider.com')
      await userEvent.type(canvas.getByTestId('password'), 'a-random-password')
    })
    
    await step('Submit form', async () => {
      await userEvent.click(canvas.getByRole('button'))
    })
    
    // Assert form submission
    await expect(
      canvas.getByText('Everything is perfect. Your account is ready!')
    ).toBeInTheDocument()
    
    // Verify mock function was called
    await expect(args.onSubmit).toHaveBeenCalled()
  },
}
```

### Advanced Play Function Patterns

#### Pre-Rendering Setup with Mount
```typescript
// src/elements/Page.stories.ts
import MockDate from 'mockdate'

export const ChristmasUI: Story = {
  async play({ mount }) {
    MockDate.set('2024-12-25')
    // ðŸ‘‡ Render the component with the mocked date
    await mount()
    // ... rest of test
  },
}
```

#### Dynamic Data Creation
```typescript
// src/elements/Page.stories.ts
export const DynamicData: Story = {
  play: async ({ mount, args }) => {
    const note = await db.note.create({
      data: { title: 'Mount inside of play' },
    })
    
    const canvas = await mount(
      // ðŸ‘‡ Pass data created inside play function to component
      <Page {...args} params={{ id: String(note.id) }} />
    )
    
    await userEvent.click(await canvas.findByRole('menuitem', { name: /login to add/i }))
  },
  argTypes: {
    // ðŸ‘‡ Make params prop un-controllable
    params: { control: { disable: true } },
  },
}
```

#### File-Level Setup with beforeEach
```typescript
// src/elements/Page.stories.ts
import MockDate from 'mockdate'

const meta: Meta<typeof Page> = {
  component: Page,
  // ðŸ‘‡ Set up for every story in the file
  async beforeEach() {
    MockDate.set('2024-02-14')
    
    // ðŸ‘‡ Reset after each story
    return () => {
      MockDate.reset()
    }
  },
}
```

### User Event API Reference

#### Core User Events
```typescript
// Complete user event examples
await userEvent.clear(canvas.getByRole('myinput'))
await userEvent.click(canvas.getByText('mycheckbox'))
await userEvent.dblClick(canvas.getByText('mycheckbox'))
await userEvent.hover(canvas.getByTestId('example-test'))
await userEvent.unhover(canvas.getByLabelText(/Example/i))
await userEvent.type(canvas.getByRole('my-input'), 'Some text')
await userEvent.keyboard('foo')
await userEvent.selectOptions(canvas.getByRole('listbox'), ['1', '2'])
await userEvent.deselectOptions(canvas.getByRole('listbox'), '1')
```

#### Complex Interaction Patterns
```typescript
// Multi-step form interaction
await step('Fill out form fields', async () => {
  const emailInput = canvas.getByRole('textbox', { name: /email/i })
  const passwordInput = canvas.getByRole('textbox', { name: /password/i })
  const checkbox = canvas.getByRole('checkbox', { name: /remember me/i })
  
  await userEvent.type(emailInput, 'test@example.com')
  await userEvent.type(passwordInput, 'password123')
  await userEvent.click(checkbox)
  
  expect(emailInput).toHaveValue('test@example.com')
  expect(passwordInput).toHaveValue('password123')
  expect(checkbox).toBeChecked()
})
```

### Mocking and State Management

#### Module Mocking
```typescript
// src/elements/NoteUI.stories.ts
import { saveNote } from '#app/actions.mock' // Mocked module
import { createNotes } from '#mocks/notes'

export const SaveFlow: Story = {
  args: {
    isEditing: true,
    note: createNotes()[0],
  },
  play: async ({ canvasElement, step }) => {
    const canvas = within(canvasElement)
    
    const saveButton = canvas.getByRole('menuitem', { name: /done/i })
    await userEvent.click(saveButton)
    
    // ðŸ‘‡ Assert on mocked function behavior
    await expect(saveNote).toHaveBeenCalled()
  },
}
```

#### State Reset Patterns
```typescript
// .storybook/preview.ts
const preview: Preview = {
  async beforeEach() {
    // Reset global state before each story
    MockDate.reset()
    // Reset any other global mocks or state
  },
  async beforeAll() {
    // Initialize global dependencies once
    await init()
  },
}
```

### Test Runner Integration

#### Command Line Execution
```bash
# Run all Storybook tests
yarn test-storybook

# Run with specific options
yarn test-storybook --watch
yarn test-storybook --coverage
```

#### CI/CD Integration
```yaml
# .github/workflows/test.yml
name: Storybook Tests

on: [push, pull_request]

jobs:
  storybook-tests:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - uses: actions/setup-node@v3
      - run: yarn install
      - run: yarn build-storybook
      - run: yarn test-storybook
```

### Interactive Debugging

#### Debugger Panel Features
- **Step-by-step execution**: View each interaction step
- **Pause/Resume**: Control test execution flow
- **Rewind**: Go back to previous steps
- **Visual feedback**: See exactly what's happening in the browser

#### Error Handling
```typescript
export const ErrorHandling: Story = {
  play: async ({ canvasElement, step }) => {
    const canvas = within(canvasElement)
    
    await step('Handle expected errors', async () => {
      try {
        await userEvent.click(canvas.getByRole('button', { name: /non-existent/i }))
      } catch (error) {
        // Handle expected errors gracefully
        expect(error.message).toContain('Unable to find')
      }
    })
  },
}
```

### Performance Testing Patterns

#### Render Performance Testing
```typescript
export const PerformanceTest: Story = {
  args: {
    data: generateLargeDataset(1000), // 1000 rows
  },
  play: async ({ canvasElement, step }) => {
    const canvas = within(canvasElement)
    
    await step('Measure render performance', async () => {
      const startTime = performance.now()
      
      const table = canvas.getByRole('table')
      expect(table).toBeInTheDocument()
      
      const endTime = performance.now()
      const renderTime = endTime - startTime
      
      // Assert reasonable render time
      expect(renderTime).toBeLessThan(100) // 100ms threshold
    })
  },
}
```

#### Memory Usage Testing
```typescript
export const MemoryTest: Story = {
  play: async ({ canvasElement, step }) => {
    await step('Monitor memory usage', async () => {
      const initialMemory = performance.memory?.usedJSHeapSize || 0
      
      // Perform memory-intensive operations
      for (let i = 0; i < 1000; i++) {
        await userEvent.click(canvas.getByRole('button'))
      }
      
      const finalMemory = performance.memory?.usedJSHeapSize || 0
      const memoryIncrease = finalMemory - initialMemory
      
      // Assert reasonable memory usage
      expect(memoryIncrease).toBeLessThan(50 * 1024 * 1024) // 50MB threshold
    })
  },
}
```

### Accessibility Testing Integration

#### Automated A11y Testing
```typescript
export const AccessibilityAudit: Story = {
  parameters: {
    a11y: {
      config: {
        rules: [
          { id: 'color-contrast', enabled: true },
          { id: 'label', enabled: true },
          { id: 'button-name', enabled: true },
          { id: 'form-field-multiple-labels', enabled: true },
        ],
      },
    },
  },
  play: async ({ canvasElement, step }) => {
    const canvas = within(canvasElement)
    
    await step('Verify accessibility attributes', async () => {
      const input = canvas.getByRole('textbox', { name: /email address/i })
      const label = canvas.getByText(/email address/i)
      
      expect(input).toHaveAttribute('type', 'email')
      expect(input).toHaveAttribute('required')
      expect(label).toBeInTheDocument()
    })
    
    await step('Test keyboard navigation', async () => {
      const input = canvas.getByRole('textbox', { name: /email address/i })
      
      await userEvent.tab()
      expect(input).toHaveFocus()
      
      await userEvent.type(input, 'test@example.com')
      expect(input).toHaveValue('test@example.com')
    })
  },
}
```

### Visual Regression Testing

#### Visual Regression Testing
```typescript
export const VisualRegression: Story = {
  args: {
    label: 'Primary Button',
    color: 'primary',
    size: 'md',
  },
  parameters: {
    viewports: [320, 768, 1200],
  },
  play: async ({ canvasElement, step }) => {
    const canvas = within(canvasElement)
    
    await step('Verify visual appearance', async () => {
      const button = canvas.getByRole('button', { name: /primary button/i })
      expect(button).toBeInTheDocument()
      expect(button).toHaveClass('btn-primary')
    })
  },
}
```

### Troubleshooting Common Issues

#### Test Isolation
- **State Reset**: Always reset state between tests using `beforeEach`
- **Mock Cleanup**: Storybook automatically restores mocks between stories
- **Component Cleanup**: Ensure components properly clean up event listeners

#### Performance Issues
- **Test Timeout**: Increase timeout for complex interactions
- **Memory Leaks**: Monitor memory usage in long-running tests
- **Async Operations**: Use `waitFor` for asynchronous operations

#### Debugging Tips
- **Interactive Debugger**: Use Storybook's interaction panel for step-by-step debugging
- **Error Permalinks**: Share error URLs for easy reproduction
- **Visual Feedback**: See exactly what's happening in the browser during tests

---

## Testing Strategy Comparison

### Component Tests vs Visual Tests
- **Component Tests**: Test functional behavior, user interactions, and business logic
- **Visual Tests**: Test visual appearance, layout, and design consistency
- **Combination**: Use both for comprehensive coverage with less maintenance
- **Recommendation**: Focus component tests on critical user workflows, use visual tests for design validation

### Component Tests vs Jest + Testing Library Alone
- **Storybook Integration**: Tests run in real browser environment vs JSDOM limitations
- **Visual Debugging**: See component during test execution vs command line output
- **Co-location**: Keep stories and tests together vs separate test files
- **Browser Features**: Access to real browser APIs vs mocked implementations
- **Debugging**: Visual debugging in browser vs command line debugging

### When to Use Each Approach

#### Use Component Tests (Storybook) For:
- User interaction workflows
- Form validation and submission
- Component state management
- Accessibility testing
- Complex user journeys
- Visual feedback validation

#### Use Unit Tests (Vitest) For:
- Pure function testing
- Utility function validation
- Component prop validation
- Event emission testing
- Simple component logic
- Performance-critical code

#### Use Visual Tests For:
- Design consistency
- Cross-browser compatibility
- Responsive design validation
- Theme variations
- Visual regression detection

---

## AI Agent Behavior

- **Test-First Approach**: Suggest writing tests before implementing features
- **Coverage Analysis**: Identify untested code paths and suggest tests
- **Pattern Consistency**: Follow established testing patterns from existing tests
- **Accessibility Focus**: Always include accessibility testing in suggestions
- **Performance Awareness**: Consider test execution time and performance impact
- **Best Practices**: Suggest testing best practices and improvements
- **Documentation**: Provide clear test documentation and examples
- **Storybook Integration**: Leverage Storybook for comprehensive E2E testing
- **Visual Testing**: Include visual regression testing
- **Component Testing**: Prioritize user behavior testing over implementation details
- **Test Strategy**: Recommend appropriate testing approach based on component complexity
alwaysApply: false
---
